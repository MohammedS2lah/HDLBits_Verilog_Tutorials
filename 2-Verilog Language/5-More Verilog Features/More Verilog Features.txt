*Conditional*
-----------------------------------------------------
module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    wire [7:0] intermediate_result1, intermediate_result2;
    
    assign intermediate_result1 = (c<d)? c: d;
    
    assign intermediate_result2 = (b<intermediate_result1)? b : intermediate_result1;
    
    assign min = (a<intermediate_result2)? a : intermediate_result2;

endmodule


-----------------------------------------------------

*Reduction*
-----------------------------------------------------
module top_module (
    input [7:0] in,
    output parity); 
    
    assign parity = ^in;

endmodule

-----------------------------------------------------

*Gates100*
-----------------------------------------------------
module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    
    assign out_and = &in;
    
    assign out_or = |in;
    
    assign out_xor = ^in;

endmodule

-----------------------------------------------------

*Vector100r*
-----------------------------------------------------
module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    integer i;
    always @(*)
        begin
            for(i=0;i<100;i=i+1)
                begin
                    out[i] = in[100-i-1]; 
                end   
        end
    
	/*
    always @(*) begin
		for (int i=0;i<$bits(out);i++)		// $bits() is a system function that returns the width of a signal.
			out[i] = in[$bits(out)-i-1];	// $bits(out) is 100 because out is 100 bits wide.
	end
    */

endmodule


-----------------------------------------------------

*Popcount255*
-----------------------------------------------------
module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    reg [7:0] counter;
    
    always @(*)
        begin
            counter = 0;
            for (int i=0; i<255; i++)
                begin
                    if(in[i]) 
                    	begin
                    		counter = counter + 1'b1;
                        end    
                end            
        
            out = counter;        
        end

endmodule


-----------------------------------------------------

*Adder100i*
-----------------------------------------------------
module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    FA_1bit FA0 (.a(a[0]), .b(b[0]), .cin(cin), .cout(cout[0]), .sum(sum[0]) );

    genvar i;
    
    generate
        for (i=1; i<$bits(sum); i++)
            begin: FA1to99
                FA_1bit FA (.a(a[i]), .b(b[i]), .cin(cout[i-1]), .cout(cout[i]), .sum(sum[i]) );
            end
    endgenerate
    
endmodule

module FA_1bit(
    input a,b,cin,
    output cout,sum);
	
    assign sum  = a^b^cin;
    assign cout = (a&b)|(b&cin)|(cin&a);
endmodule


-----------------------------------------------------

*Bcdadd100*
-----------------------------------------------------
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    genvar i;
    
    wire [99:0] cout_int;
    
    bcd_fadd BCD_Adder0 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_int[0]), .sum(sum[3:0]));
    
    generate
        for (i=4; i<$bits(sum); i=i+4)
            begin: BCD_1to99_adders
                bcd_fadd BCD_Adders (.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_int[(i/4)-1]), .cout(cout_int[(i/4)]), .sum(sum[i+3:i])); 
            end
    endgenerate
    
    assign cout = cout_int[99];
    
endmodule



